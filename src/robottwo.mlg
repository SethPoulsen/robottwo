  DECLARE PLUGIN "robottwo_plugin"

{

(* If we forget this line and include our own tactic definition using
  TACTIC EXTEND, as below, then we get the strange error message
  no implementation available for Tacentries, only when compiling
  theories/Loader.v
*)
(* open Ltac_plugin *)
open Pp
(* This module defines the types of arguments to be used in the
   EXTEND directives below, for example the string one. *)
open Stdarg

let extract_main_goal pstate =
  let sigma, env = Declare.Proof.get_current_context pstate in
  let debug sigma = Termops.pr_evar_map ~with_univs:true None env sigma in
  let state = (strbrk "State: " ++ debug sigma) in
  let s = Pp.string_of_ppcmds state in
  let start, finish = (String.index s '-') + 1, (String.index s ']') in
    Pp.str (String.sub s start (finish - start))
  ;;

}


VERNAC COMMAND EXTEND PreExplain CLASSIFIED AS QUERY
| ![ proof_query ] [ "PreExplain" "intro" ident(i)] ->
  { fun ~pstate ->
    Feedback.msg_notice (extract_main_goal pstate)
  }
| ![ proof_query ] [ "PreExplain" "exists" nat(n)] ->
  { fun ~pstate -> Feedback.msg_notice (Pp.str "") }
| ![ proof_query ] [ "PreExplain" "unfold" ident(i) ] ->
  { fun ~pstate -> Feedback.msg_notice (Pp.str "") }
| ![ proof_query ] [ "PreExplain" "ring" ] ->
  { fun ~pstate -> Feedback.msg_notice (Pp.str "") }
END


VERNAC COMMAND EXTEND PostExplain CLASSIFIED AS QUERY
| ![ proof_query ] [ "PostExplain" "intro" ident(i)] ->
  { fun ~pstate ->
    (* let sigma, env = Declare.Proof.get_current_context pstate in
    let pprf = Proof.partial_proof (Declare.Proof.get pstate) in
    Feedback.msg_notice
      (Pp.prlist_with_sep Pp.fnl (Printer.pr_econstr_env env sigma) pprf) *)
   (* ; *)
    let sigma, env = Declare.Proof.get_current_context pstate in
    let pprf = Proof.partial_proof (Declare.Proof.get pstate) in
    Feedback.msg_notice
      (Pp.prlist_with_sep Pp.fnl (Printer.pr_econstr_env env sigma) pprf) ;

    let debug sigma = Termops.pr_evar_map ~with_univs:true None env sigma in
    Feedback.msg_notice (strbrk "State: " ++ debug sigma) ;

    let p: Proof.t = Declare.Proof.get pstate in
    Feedback.msg_notice (strbrk "Proof: " ++ (Proof.pr_proof p))

    (* ; *)
    (* let pprf = Proof.partial_proof (Declare.Proof.get_open_goals pstate) in
    let Declare.Proof.{ goals; stack; sigma } = Declare.Proof.data pstate in
    Feedback.msg_notice
      (Pp.prlist_with_sep Pp.fnl (Printer.pr_econstr_env env sigma) goals) *)
  }
| ![ proof_query ] [ "PostExplain" "exists" nat(n)] ->
  { fun ~pstate -> Feedback.msg_notice (Pp.str "")
  (* ; let sigma, env = Declare.Proof.get_current_context pstate in
  let debug sigma = Termops.pr_evar_map ~with_univs:true None env sigma in
    Feedback.msg_notice (strbrk "State: " ++ debug sigma) *)
 }
| ![ proof_query ] [ "PostExplain" "unfold" ident(i) ] ->
  { fun ~pstate -> Feedback.msg_notice (Pp.str "")
  (* ; let sigma, env = Declare.Proof.get_current_context pstate in
  let debug sigma = Termops.pr_evar_map ~with_univs:true None env sigma in
    Feedback.msg_notice (strbrk "State: " ++ debug sigma) *)
 }
| ![ proof_query ] [ "PostExplain" "ring" ] ->
  { fun ~pstate -> Feedback.msg_notice (Pp.str "")
  (* ; let sigma, env = Declare.Proof.get_current_context pstate in
  let debug sigma = Termops.pr_evar_map ~with_univs:true None env sigma in
    Feedback.msg_notice (strbrk "State: " ++ debug sigma) *)
 }
END
