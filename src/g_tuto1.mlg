  DECLARE PLUGIN "tuto1_plugin"

{

(* If we forget this line and include our own tactic definition using
  TACTIC EXTEND, as below, then we get the strange error message
  no implementation available for Tacentries, only when compiling
  theories/Loader.v
*)
(* open Ltac_plugin *)
open Pp
(* This module defines the types of arguments to be used in the
   EXTEND directives below, for example the string one. *)
open Stdarg

}

VERNAC COMMAND EXTEND ExploreProof CLASSIFIED AS QUERY
| ![ proof_query ] [ "ExploreProof" ] ->
  { fun ~pstate ->
    (* let sigma, env = Declare.Proof.get_current_context pstate in
    let pprf = Proof.partial_proof (Declare.Proof.get pstate) in
    Feedback.msg_notice
      (Pp.prlist_with_sep Pp.fnl (Printer.pr_econstr_env env sigma) pprf) *)
   (* ; *)
    let sigma, env = Declare.Proof.get_current_context pstate in
    let pprf = Proof.partial_proof (Declare.Proof.get pstate) in
    Feedback.msg_notice
      (Pp.prlist_with_sep Pp.fnl (Printer.pr_econstr_env env sigma) pprf) ;

    let debug sigma = Termops.pr_evar_map ~with_univs:true None env sigma in
    Feedback.msg_notice (strbrk "State: " ++ debug sigma) ;

    let p: Proof.t = Declare.Proof.get pstate in
    Feedback.msg_notice (strbrk "Proof: " ++ (Proof.pr_proof p))


    (* let pprf = Proof.partial_proof (Declare.Proof.get_open_goals pstate) in *)
    (* let Declare.Proof.{ goals; stack; sigma } = Declare.Proof.data pstate in
    Feedback.msg_notice
      (Pp.prlist_with_sep Pp.fnl (Printer.pr_econstr_env env sigma) goals) *)
  }
| ![ proof_query ] [ "ExploreProof" "intro" ident(i)] ->
  { fun ~pstate ->
    let sigma, env = Declare.Proof.get_current_context pstate in
    let pprf = Proof.partial_proof (Declare.Proof.get pstate) in
    Feedback.msg_notice
      (Pp.prlist_with_sep Pp.fnl (Printer.pr_econstr_env env sigma) pprf) ;

    let debug sigma = Termops.pr_evar_map ~with_univs:true None env sigma in
    Feedback.msg_notice (strbrk "State: " ++ debug sigma) ;

    let p: Proof.t = Declare.Proof.get pstate in
    Feedback.msg_notice (strbrk "Proof: " ++ (Proof.pr_proof p))
  }
| ![ proof_query ] [ "ExploreProof" "exists" nat(n)] ->
  { fun ~pstate ->
    let sigma, env = Declare.Proof.get_current_context pstate in
    let pprf = Proof.partial_proof (Declare.Proof.get pstate) in
    Feedback.msg_notice
      (Pp.prlist_with_sep Pp.fnl (Printer.pr_econstr_env env sigma) pprf) ;

    let debug sigma = Termops.pr_evar_map ~with_univs:true None env sigma in
    Feedback.msg_notice (strbrk "State: " ++ debug sigma) ;

    let p: Proof.t = Declare.Proof.get pstate in
    Feedback.msg_notice (strbrk "Proof: " ++ (Proof.pr_proof p))
  }
  | ![ proof_query ] [ "ExploreProof" "unfold" ident(i) ] ->
  { fun ~pstate ->
    let sigma, env = Declare.Proof.get_current_context pstate in
    let pprf = Proof.partial_proof (Declare.Proof.get pstate) in
    Feedback.msg_notice
      (Pp.prlist_with_sep Pp.fnl (Printer.pr_econstr_env env sigma) pprf) ;

    let debug sigma = Termops.pr_evar_map ~with_univs:true None env sigma in
    Feedback.msg_notice (strbrk "State: " ++ debug sigma) ;

    let p: Proof.t = Declare.Proof.get pstate in
    Feedback.msg_notice (strbrk "Proof: " ++ (Proof.pr_proof p))
  }
  | ![ proof_query ] [ "ExploreProof" "ring" ] ->
  { fun ~pstate ->
    let sigma, env = Declare.Proof.get_current_context pstate in
    let pprf = Proof.partial_proof (Declare.Proof.get pstate) in
    Feedback.msg_notice
      (Pp.prlist_with_sep Pp.fnl (Printer.pr_econstr_env env sigma) pprf) ;

    let debug sigma = Termops.pr_evar_map ~with_univs:true None env sigma in
    Feedback.msg_notice (strbrk "State: " ++ debug sigma) ;

    let p: Proof.t = Declare.Proof.get pstate in
    Feedback.msg_notice (strbrk "Proof: " ++ (Proof.pr_proof p))
  }
END
